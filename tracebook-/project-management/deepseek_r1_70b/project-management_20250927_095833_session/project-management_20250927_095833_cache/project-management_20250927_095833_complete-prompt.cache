
===============================================================
ITERATION : 0
===============================================================
**READ THE ENTIRE REQUEST BEFORE GENERATING ANYTHING**

The following text is a request to GENERATE ABAC rules. The text is separated into sections. To begin the text will name the section and the purpose of the section in this request.

	PROMPT section:  This will be the main request we need accomplished through the query.

    ATTRIBUTE_DESCRIPTION section: is a sample policy for a healthcare organization.
     Analyze this file to better understand ABAC rule attributes for our organization. Also use this section to better understand the ATTRIBUTE_DATA section    

    ATTRIBUTE_DATA_FORMAT_DESCRIPTION: This section explains the format of the ATTRIBUTE DATA described in the attribute data section.

    ATTRIBUTE_DATA section: is the attribute data for our organization. This includes resources and users. Use these to create the ABAC rules being requested. 

    RULES_FORMAT_DESCRIPTION: This section explains the format of the ABAC rules that we need you (the LLM) to generate.

    GROUND_TRUTH_ACL section: This section contains our organizations entire ACL (access Control List), this is the list that needs to be converted into a set of
     ABAC rules that grant the exact same permissions. 
     this is also known as the ground truth ACL.

	ADDITIONAL_INSTRUCTIONS section: contains additional instructions you need to follow. instructions that have to do with output results,
     the process, and other rules to help you (the LLM model) generate the exact results needed.


## PROMPT ##
    Our organization needs you (the LLM) to use the 
    ATTRIBUTE_DESCRIPTION , ATTRIBUTE_DATA_FORMAT_DESCRIPTION, ATTRIBUTE_DATA, RULES_FORMAT_DESCRIPTION, and ADDITIONAL_INSTRUCTIONS sections
    to generate a set of ABAC Rules that will give the same exact permissions that the GROUND_TRUTH_ACL gives. No less permission and no more permissions
    than what is in the GROUND_TRUTH_ACL.
        THE GOAL IS TO CREATE A SET OF ABAC RULES THAT WILL GENERATE THE SAME SET OF PERMISSIONS THAT THE ACL IN THE GROUND_TRUTH_ACL section,
        ANY PERMISSION THAT IS MISSED, BY YOUR GENERATED ABAC RULES, OR THAT IS OVER PEMRITTED BY YOUR ABAC RULE SET WILL BE CONSIDERED A FAILURE.
            This is mission critical so accuracy is critical.
    You (the LLM) must generate the fewest amount of rules that give the same exact permissions as the ACL that was provided.
    If you detect that you made a mistake in your reasoning at any point, correct yourself.


## ATTRIBUTE_DESCRIPTION ##
# Policy Description: Project Management 
*Vesion: v20250308*


This is a sample policy developed by Xu et al. (2015). The policy manages access by department managers, project leaders, employees, contractors, auditors, accountants, and planners to budgets,
schedules, and tasks associated with projects.

**Reference**: Zhongyuan Xu and Scott D. Stoller. *Mining attribute-based access control policies.* IEEE Transactions on Dependable and Secure Computing, 12(5):533–545, September–October 2015.

## Attributes

### Subject/User Attributes
The subjects of this policy include accountants, auditors, planners, managers, project leaders, and technical workers (designers and coders). The following attributes are used to describe the subjects.

| Attribute Name      | Multiplicity, Type     | Description                                               | Example Values                                     |
|--------------------|------------------|-----------------------------------------------------------|--------------------------------------------------|
| uid          | Single, String   | User’s unique identifier.                                  | acc1, aud2, etc.                         |
| adminRoles          | Multi, Set\<String>   | The user's administrative roles.        | {auditor, accountant}, etc.             |
| projects        | Multi, Set\<String>  | Projects the user is working on.                     | {proj11, proj12}, etc.                      |
| projectsLed         | Multi, Set\<String>   | projects led by the user. This is specified explicitly, instead of being implied by a user working on a project and having projectLeader among his administrative roles, because the user might work on some projects in non-leader roles.             | {proj21, proj22}, etc. |
| expertise    | Multi, Set\<String>   | The user's areas of technical expertise. | {design, coding}, etc.                          |
| tasks    | Multi, Set\<String>   | Tasks assigned to the user.                     | {proj11task1a, proj11task1propa}, etc.  |
| department    | Single, String   | The department that the user is in.                     | dept1, dept2, etc.  |
| isEmployee    | Single, Boolean    | Specifying if the user is an employee (True) or a contractor (False).                     | True, False  |


### Resource Attributes
The resources of this policy include budgets, schedules, and tasks for different projects. The following attributes are used to describe the resources.

| Attribute Name      | Multiplicity, Type     | Description                                               | Example Values                                     |
|--------------------|------------------|-----------------------------------------------------------|--------------------------------------------------|
| rid      | Single, String   | Resource’s unique identifier                             | proj11budget, proj11task1a, etc.               |
| type             | Single, String   | Type of resource being accessed.                        | task, budget, schedule                      |
| project       | Single, String   | The project that the task, schedule, or budget is for.                 | proj11, proj21, etc.                            |
| department          | Single, String   | The department that the associated project is in.                      | dept1, dept2, etc.                           |
| expertise      | Multi, Set\<String>   | The areas of technical expertise required to work on the task.            | {design, coding}, etc.                             |
| proprietary    | Single, Boolean    | Specifiying if the task involves proprietary information, which is accessible only to employees (not contractors).                     | True, False  |


## ATTRIBUTE_DATA_FORMAT_DESCRIPTION ##

    This section outlines the format of attribute data described in the ATTRIBUTE DATA section. 

   ATTRIBUTE_DATA section contains lines of the forms:

    userAttrib(uid, attribute1=value1, attribute2=value2, ...)

    resourceAttrib(rid, attribute1=value1, attribute2=value2, ...)
    

    The `userAttrib` and `resourceAttrib` lines define the users (subjects) and resources in the policy, respectively.
    - The first argument of a `userAttrib` is automatically assigned to an attribute named `uid`, which is the id of the user. 
    The first argument of a `resourceAttrib` is automatically assigned to an attribute named `rid`, which is the id of the resource.  
    - `value1`, `value2`, ... are atomic values or sets of atomic values.
    - An atomic value is a string that starts with a character other than a left curly brace.  
    - A set has the form `{element1 element2 ...}`. **Note that elements of a set are separated by spaces, not commas.**

## ATTRIBUTE_DATA ##
# ABAC policy for a project management system.

# Note that the two words "user" and "subject" are used interchangeably in this document.

# Please refer to the policy description document for the detailed descriptions subject attributes and resource attributes. Note that some attributes might be irrelevant for some users and resources.

#------------------------------------------------------------
# user attribute data
#------------------------------------------------------------

# naming convention: proj<i><j> is the j'th project in department i

# accountants
userAttrib(acc1, adminRoles={accountant}, projects={proj11 proj12})
userAttrib(acc2, adminRoles={accountant}, projects={proj21 proj22})

# auditors
userAttrib(aud1, adminRoles={auditor}, projects={proj11 proj12})
userAttrib(aud2, adminRoles={auditor}, projects={proj21 proj22})

# planners
userAttrib(plan1, adminRoles={planner}, projects={proj11 proj12})
userAttrib(plan2, adminRoles={planner}, projects={proj21 proj22})

# managers
userAttrib(mgr1, adminRoles={manager}, department=dept1)
userAttrib(mgr2, adminRoles={manager}, department=dept2)

# project leaders
userAttrib(ldr11, projects={proj11 proj12}, projectsLed={proj11}, department=dept1)
userAttrib(ldr12, projects={proj12}, projectsLed={proj12}, department=dept1)
userAttrib(ldr2, projects={proj21 proj22}, projectsLed={proj21 proj22}, department=dept2)

# technical workers - designers
userAttrib(des11, expertise={design}, projects={proj11}, isEmployee=True, tasks={proj11task1a proj11task1propa})
userAttrib(des12, expertise={design}, projects={proj12}, isEmployee=False, tasks={proj12task1a proj12task1propa})
userAttrib(des21, expertise={design}, projects={proj21}, isEmployee=True, tasks={proj21task1a proj21task1propa})
userAttrib(des22, expertise={design}, projects={proj22}, isEmployee=False, tasks={proj22task1a proj22task1propa})

# technical workers - coders
userAttrib(code11, expertise={coding}, projects={proj11}, isEmployee=True, tasks={proj11task2a proj11task2propa})
userAttrib(code12, expertise={coding}, projects={proj12}, isEmployee=False, tasks={proj12task2a proj12task2propa})
userAttrib(code21, expertise={coding}, projects={proj21}, isEmployee=True, tasks={proj21task2a proj21task2propa})
userAttrib(code22, expertise={coding}, projects={proj22}, isEmployee=False, tasks={proj22task2a proj22task2propa})

#------------------------------------------------------------
# resource attribute data
#------------------------------------------------------------

# for each project, for each area of expertise, for proprietary in
# {True,False}, there is an assigned task (whose rid ends with "a") and an
# unassigned task.

# proj11
resourceAttrib(proj11budget,type=budget, project=proj11, department=dept1)
resourceAttrib(proj11sched, type=schedule, project=proj11, department=dept1)
# un-proprietary tasks
resourceAttrib(proj11task1a, type=task, project=proj11, department=dept1, expertise={design}, proprietary=False)
resourceAttrib(proj11task2a, type=task, project=proj11, department=dept1, expertise={coding}, proprietary=False)
resourceAttrib(proj11task1, type=task, project=proj11, department=dept1, expertise={design}, proprietary=False)
resourceAttrib(proj11task2, type=task, project=proj11, department=dept1, expertise={coding}, proprietary=False)
# proprietary tasks
resourceAttrib(proj11task1propa, type=task, project=proj11, department=dept1, expertise={design}, proprietary=True)
resourceAttrib(proj11task2propa, type=task, project=proj11, department=dept1, expertise={coding}, proprietary=True)
resourceAttrib(proj11task1prop, type=task, project=proj11, department=dept1, expertise={design}, proprietary=True)
resourceAttrib(proj11task2prop, type=task, project=proj11, department=dept1, expertise={coding}, proprietary=True)

# proj12
resourceAttrib(proj12budget,type=budget, project=proj12, department=dept1)
resourceAttrib(proj12sched, type=schedule, project=proj12, department=dept1)
# un-proprietary tasks
resourceAttrib(proj12task1a, type=task, project=proj12, department=dept1, expertise={design}, proprietary=False)
resourceAttrib(proj12task2a, type=task, project=proj12, department=dept1, expertise={coding}, proprietary=False)
resourceAttrib(proj12task1, type=task, project=proj12, department=dept1, expertise={design}, proprietary=False)
resourceAttrib(proj12task2, type=task, project=proj12, department=dept1, expertise={coding}, proprietary=False)
# proprietary tasks
resourceAttrib(proj12task1propa, type=task, project=proj12, department=dept1, expertise={design}, proprietary=True)
resourceAttrib(proj12task2propa, type=task, project=proj12, department=dept1, expertise={coding}, proprietary=True)
resourceAttrib(proj12task1prop, type=task, project=proj12, department=dept1, expertise={design}, proprietary=True)
resourceAttrib(proj12task2prop, type=task, project=proj12, department=dept1, expertise={coding}, proprietary=True)

# proj21
resourceAttrib(proj21budget,type=budget, project=proj21, department=dept2)
resourceAttrib(proj21sched, type=schedule, project=proj21, department=dept2)
# un-proprietary tasks
resourceAttrib(proj21task1a, type=task, project=proj21, department=dept2, expertise={design}, proprietary=False)
resourceAttrib(proj21task2a, type=task, project=proj21, department=dept2, expertise={coding}, proprietary=False)
resourceAttrib(proj21task1, type=task, project=proj21, department=dept2, expertise={design}, proprietary=False)
resourceAttrib(proj21task2, type=task, project=proj21, department=dept2, expertise={coding}, proprietary=False)
# proprietary tasks
resourceAttrib(proj21task1propa, type=task, project=proj21, department=dept2, expertise={design}, proprietary=True)
resourceAttrib(proj21task2propa, type=task, project=proj21, department=dept2, expertise={coding}, proprietary=True)
resourceAttrib(proj21task1prop, type=task, project=proj21, department=dept2, expertise={design}, proprietary=True)
resourceAttrib(proj21task2prop, type=task, project=proj21, department=dept2, expertise={coding}, proprietary=True)

# proj22
resourceAttrib(proj22budget,type=budget, project=proj22, department=dept2)
resourceAttrib(proj22sched, type=schedule, project=proj22, department=dept2)
# un-proprietary tasks
resourceAttrib(proj22task1a, type=task, project=proj22, department=dept2, expertise={design}, proprietary=False)
resourceAttrib(proj22task2a, type=task, project=proj22, department=dept2, expertise={coding}, proprietary=False)
resourceAttrib(proj22task1, type=task, project=proj22, department=dept2, expertise={design}, proprietary=False)
resourceAttrib(proj22task2, type=task, project=proj22, department=dept2, expertise={coding}, proprietary=False)
# proprietary tasks
resourceAttrib(proj22task1propa, type=task, project=proj22, department=dept2, expertise={design}, proprietary=True)
resourceAttrib(proj22task2propa, type=task, project=proj22, department=dept2, expertise={coding}, proprietary=True)
resourceAttrib(proj22task1prop, type=task, project=proj22, department=dept2, expertise={design}, proprietary=True)
resourceAttrib(proj22task2prop, type=task, project=proj22, department=dept2, expertise={coding}, proprietary=True)


## RULES_FORMAT_DESCRIPTION ##
    All of the output ABAC rules must follow the following format:
        rule(subCond; resCond; acts; cons)
    
    - `subCond` is a subject condition. It is a conjunction, with the conjuncts separated by commas. Each conjunct has the form 
    `attr [ {value1 value2 ...}`, where `attr` is a single-valued user attribute and `[` denotes the "in" 
    operator (note that elements of a set are separated by spaces, not commas), or 
    `attr ] value`
    , where attr is a muli-valued attribute, value is an atomic value, and `]` denotes the "contains" operator.

    - `resCond` is a resource condition. The syntax is analogous to the syntax for subject condition.

    - `acts` is a set of actions.

    - `cons` is a constraint. It is a conjunction of atomic constraints, with the
    conjuncts separated by commas. An atomic constraint is a formula of one of the following forms:
    
    aum > arm 
    aus [ arm
    aum ] ars
    aus = ars
    
    , where `aus` is a single-valued user attribute,
    `aum` is a multi-valued user attribute,
    `ars` is a single-valued resource attribute,
    `arm` is a multi-valued resource attribute. Note that `>` denotes the "supseteq" (⊇) operator.

    This is an example of a rule:
        rule(provider [ {eWorkforce}, position [ {helpdeskOperator}; type [ {contract}, contractStatus [ {active}, tenantType [ {primary}; {createOneTimeWorkOrder createRecurrentWorkOrder}; assignedTenant = tenant)


## GROUND_TRUTH_ACL ##
plan1, proj12sched, read
code21, proj21task2prop, read
ldr11, proj11budget, write
code21, proj21task2propa, setStatus
code21, proj21task2a, request
plan2, proj22sched, read
des22, proj22task1a, read
des22, proj22task1propa, setStatus
ldr12, proj12sched, read
des12, proj12task1, read
code21, proj21task2propa, read
ldr11, proj11sched, write
des11, proj11task1a, read
ldr12, proj12budget, write
des22, proj22sched, read
acc2, proj22sched, read
code11, proj11task2propa, setStatus
code22, proj22sched, read
code22, proj22task2, read
plan2, proj21sched, read
code11, proj11sched, read
des22, proj22task1, read
des11, proj11task1prop, request
code21, proj21task2, read
code12, proj12task2, read
acc1, proj11sched, read
code22, proj22task2a, read
code22, proj22task2, request
code21, proj21task2propa, request
code11, proj11task2prop, read
code11, proj11task2prop, request
des11, proj11sched, read
ldr2, proj22sched, read
code22, proj22task2a, setStatus
acc2, proj21sched, read
des12, proj12task1a, setStatus
des12, proj12task1propa, setStatus
code11, proj11task2, read
des21, proj21task1prop, read
code12, proj12sched, read
des21, proj21task1propa, read
des21, proj21task1propa, setStatus
des11, proj11task1propa, setStatus
des22, proj22task1a, request
code11, proj11task2a, request
des11, proj11task1propa, request
des11, proj11task1prop, read
code11, proj11task2propa, read
code22, proj22task2a, request
des21, proj21task1, read
des11, proj11task1a, setStatus
des22, proj22task1a, setStatus
ldr2, proj21budget, read
aud2, proj22sched, read
des21, proj21task1propa, request
des21, proj21sched, read
des12, proj12task1a, request
des21, proj21task1a, read
ldr11, proj12sched, read
aud1, proj11sched, read
ldr12, proj12sched, write
aud1, proj12sched, read
code21, proj21task2prop, request
code21, proj21task2a, read
des11, proj11task1, read
ldr11, proj11sched, read
code21, proj21task2a, setStatus
code11, proj11task2a, setStatus
des22, proj22task1, request
code12, proj12task2, request
code12, proj12task2a, request
ldr2, proj22sched, write
ldr2, proj22budget, read
des21, proj21task1, request
des12, proj12sched, read
ldr12, proj12budget, read
code12, proj12task2propa, setStatus
code11, proj11task2a, read
des12, proj12task1a, read
des21, proj21task1a, setStatus
des11, proj11task1propa, read
des11, proj11task1, request
des11, proj11task1a, request
des21, proj21task1prop, request
code21, proj21task2, request
code12, proj12task2a, setStatus
ldr11, proj11budget, read
aud2, proj21sched, read
des21, proj21task1a, request
acc1, proj12sched, read
ldr2, proj22budget, write
ldr2, proj21sched, write
code22, proj22task2propa, setStatus
ldr2, proj21budget, write
plan1, proj11sched, read
code11, proj11task2, request
code12, proj12task2a, read
code11, proj11task2propa, request
code21, proj21sched, read
ldr2, proj21sched, read
des12, proj12task1, request

## ADDITIONAL_INSTRUCTIONS

        This section provides additional instructions to assist you output propper ABAC rules.

        This is also divided into sections, the following is a description on the sections. 
        Failure to adhere to any of these rules will result in a failed query on your (the LLM) part.

            OUTPUT_FORMAT section: The output section describes how to format your (the LLMs) response. Including syntax, restrictions, and content. 
            
            ABAC_RULES section, is section dedicated to helping you (the LLM) produce more consistent and correct abac rules. You (the LLM) are to follow these rules strictly.

            The LLM_IMPROVEMENT section, has other instructions to help you (the LLM) produce better results.



        OUTPUT_FORMAT:
            1. Only respond with the ABAC rules being requested.
            2. Each rule should follow strict syntax described in the RULES_FORMAT_DESCRIPTION section.
            3. Each rule should be in its own line.
                    verify for each line:
                    line.startswith("rule(") and line.endswith(")")
                    line.count(";") == 3                
            4. Respond only with plain text, no mark-up or other type of formatting. 
                a. unseen values are forbidden.
            9. DO NOT INCLUDE ANY ``` at the beginnig or end of a response
         


        ABAC_RULES:
            
            1. ABAC rules should avoid using uid and rid attributes. 
                a. Do not hard code any ids, the rules should be dynamic.
            2. The generated rules must as concise as possible.
                a. Check all ABAC rules for redundancy, keep rules to strict minimum. 
                b. Consider removing any conjuncts in subject condition, resource condition, and constraints if that does not affect the permission given by the rule.
            6. You (the LLM) are allowed to combine rules for actions if they should grant the same access. 
                a. For example: rule (; subj ] {math}; {read, write, createNote}; class=class )
            7. ABAC rules do not need to dictate permit or deny as a section.
                a. INCORRECT = rule (; subj ] {math}; {read}; class=class, PERMIT )
            8. DO NOT ADD, REMOVE, OR EDIT ATTRIBUTES.
            9. Do not use synonyms when describing actions, stick to the action on the ACL list ONLY.


     






